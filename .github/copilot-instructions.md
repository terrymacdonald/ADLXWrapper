# Copilot Instructions for ADLXWrapper

- **Goal**: A safe C# wrapper over AMD ADLX native DLLs (vtable COM style) targeting Windows x64, .NET 10.0. Generated bindings live in `ADLXWrapper/cs_generated/`; hand-written helpers live in the project root.
- **Initialization pattern**: Always create the API via `using var adlx = ADLXApi.Initialize();` (or `InitializeWithCallerAdl` if integrating with existing ADL). Retrieve services from `adlx.GetSystemServices()` and wrap returned pointers in `ComPtr<T>` for lifetime safety.
- **DLL loading**: `ADLXApi` dynamically loads `amdadlx64.dll` via `LoadLibraryEx` with search flags. If you change DLL names or search paths, keep `ADLXNative.GetDllName()` and `ADLXApi.LoadADLXDll()` consistent. Surface errors via `ADLXException`.
- **Vtable interop**: Manual vtable layouts live in `ADLXVTables.cs`; generated interfaces/enums in `cs_generated/`. When calling vtable functions directly, cast through delegates with `Marshal.GetDelegateForFunctionPointer` and respect `StdCall` calling convention.
- **Helpers & data shapes**: Use existing helpers as patterns:
  - GPUs: `ADLXGpuHelpers.EnumerateAllGpus` → `GpuInfo` (serializable via Newtonsoft.Json) with fields like `Name`, `UniqueId`, `TotalVRAM`, `VRAMType`, `PNPString`.
  - Displays: `ADLXDisplayHelpers.EnumerateAllDisplays` → `DisplayInfo` with EDID, connector/scan type, refresh, GPU linkage.
  - Lists: `ADLXListHelpers` offers `GetListSize`, `GetListItemAt`; callers must dispose returned pointers (prefer `ComPtr`).
- **Disposal rules**: `ComPtr<T>` auto-calls `Release()` on dispose; do not manually release raw pointers owned by a `ComPtr`. `ADLXApi.Dispose` calls `ADLXTerminate` then frees the DLL; after disposal any API call should throw `ObjectDisposedException` (tests assert this).
- **Build workflow** (Windows PowerShell):
  - `./prepare_adlx.ps1` downloads/validates ADLX SDK into `ADLX/` (checks required headers/cpp files).
  - `./build_adlx.ps1` restores, cleans, builds `ADLXWrapper.sln` in Debug, sets version from `VERSION` + git commit count.
  - Direct build: `dotnet build ADLXWrapper/ADLXWrapper.csproj` (ClangSharp bindings generated before compile via MSBuild targets).
- **Tests**: xUnit in `ADLXWrapper.Tests` (hardware-aware). Run via `./test_adlx.ps1` or `dotnet test ADLXWrapper.Tests/ADLXWrapper.Tests.csproj`. Tests skip when no AMD GPU (`HardwareDetection` via WMI vendor 1002) or ADLX DLL missing; they are read-only (no tuning changes).
- **Generated code contract**: `ADLXWrapper.csproj` target `GenerateBindings` runs `ClangSharpPInvokeGenerator @ClangSharpConfig.rsp`, writes to `cs_generated/` and cleans on `dotnet clean`. Do not hand-edit generated files; adjust headers/config instead.
- **Versioning**: `build_adlx.ps1` and MSBuild target `SetVersionFromGit` compute `MAJOR.MINOR` from `VERSION`, `PATCH` from git commit count. Keep `VERSION` updated if bumping major/minor.
- **Platform assumptions**: Windows-only, x64, .NET 10.0. Ensure AMD Adrenalin drivers (with ADLX) are installed for runtime/tests; `IsADLXDllAvailable` is the lightweight preflight.
- **Samples**: Reference usage patterns in `ADLXWrapper/README.md` and `Samples/*` solutions for enumeration/printing flows.
- **When extending**: Follow existing helper style—pull raw interfaces via system/display services, materialize into immutable infos, JSON-serializable, and avoid mutating hardware state unless intentionally adding `Apply`-style methods.
- **Use ClangSharp enums where possible**: Prefer generated enums (e.g., `ADLX_VRAM_TYPE`) over custom ones to maintain consistency with ADLX definitions and ensure that new ADLX version updates autopmatically update the enum selection as well.
